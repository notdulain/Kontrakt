import java_cup.runtime.*;
import ast.*;
import java.util.*;

//parser code section
parser code {:
  private Program program = new Program();
  private boolean hadErrors = false;
  
  public Program getProgram() {
    return program;
  }
  public boolean hadErrors() { return hadErrors; }

  @Override
  public void report_error(String message, Object info) {
    hadErrors = true;

    int lineNum = -1;
    if (info instanceof Symbol) {
      Symbol s = (Symbol) info;
      lineNum = s.left + 1;
    } else if (this.cur_token != null) {
      lineNum = this.cur_token.left + 1;
    }

    if (lineNum >= 0) System.err.println("Line " + lineNum + ": " + message);
    else System.err.println("Line ?: " + message);
  }
  
  @Override
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
  }

  // Suppress CUP's generic syntax error; rely on specific error rules.
  @Override
  public void syntax_error(Symbol cur_token) {
    // no-op
  }

  // When CUP can't recover, throw a simple exception without printing
  // the huge expected-classes list. Main will handle exit.
  @Override
  public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
    throw new Exception("parse failed");
  }

  //helper to track the line
  private void errorAt(String msg, int left, int right) {
    report_error(msg, new java_cup.runtime.Symbol(sym.error, left, right, null));
  }
:}

//Terminals (tokens from the scanner)
terminal CONFIG, TEST, EXPECT;
terminal BASE_URL;
terminal GET, POST, PUT, DELETE;
terminal String NUMBER, IDENTIFIER, STRING;
terminal LBRACE, RBRACE, SEMICOLON;
terminal STATUS, EQUALS;
terminal BODY;
terminal HEADER, CONTAINS;
terminal LET;

//non-terminals (grammar rules)
non terminal Program program;
non terminal Config config_block;
non terminal Config config_items_list;
non terminal Test test_block;
non terminal test_block_list; // void (adds to program directly)
non terminal Statement statement;
non terminal List<Statement> statement_list;
non terminal Assertion assertion;
non terminal String request_body; // returns body string or null
non terminal Variable variable_decl;
non terminal variable_list; // void (adds to program directly)

//grammar
start with program;

//a program will be one or more test blocks
program ::= 
  config_block:cfg variable_list test_block_list:tests
    {: 
      parser.program.setConfig(cfg);
      RESULT = parser.program;
      //System.out.println("‚úÖ Built AST: " + RESULT);
    :}
  ;

//config items list - builds and returns a Config
config_items_list ::=
    /* empty */
    {: 
      RESULT = new Config();         // Step 1: Create empty Config
    :}
  | config_items_list:cfg BASE_URL EQUALS STRING:url SEMICOLON
    {: 
      cfg.setBaseUrl(url);           // Step 2: Add base_url to THIS Config
      RESULT = cfg;                  // Step 3: Return the updated Config
      //System.out.println("  üîó base_url = " + url);
    :}
  | config_items_list:cfg HEADER STRING:key EQUALS STRING:value SEMICOLON
    {: 
      cfg.addHeader(key, value);     // Step 2: Add header to THIS Config
      //System.out.println("  üìã header " + key + " = " + value);
      RESULT = cfg;                  // Step 3: Return the updated Config
    :}
  ;

// config_block just wraps it
config_block ::=
    /* empty */
    {:
      RESULT = null;
    :}
  | CONFIG LBRACE config_items_list:cfg RBRACE
    {:
      RESULT = cfg;  // Return the built Config
      //System.out.println("‚öôÔ∏è  Config: " + cfg);
    :}
  ;

//the main segment of our DSL: "test Login {...}"
test_block ::= 
    TEST IDENTIFIER:name LBRACE statement_list:stmts RBRACE
    {: 
      RESULT = new Test(name, stmts);
      //System.out.println("üß™ Test: " + RESULT);
    :}
  ;

//handling one or more test blocks
test_block_list ::=
    test_block:t
    {: 
      parser.program.addTest(t); // No RESULT needed
    :}
  | test_block_list test_block:t
    {: 
      parser.program.addTest(t); // No RESULT needed
    :}
  ;

//statement rule
statement ::=
    GET STRING:path SEMICOLON
    {: 
      //System.out.println("  üì° GET " + path);
      RESULT = new Request(HttpMethod.GET, path);
    :}
  | POST STRING:path LBRACE request_body:body RBRACE SEMICOLON
    {: 
      //System.out.println("  üì° POST " + path);
      Request req = new Request(HttpMethod.POST, path);
      if (body != null) req.setBody(body);
      RESULT = req;
    :}
  | PUT STRING:path LBRACE request_body:body RBRACE SEMICOLON
    {: 
      //System.out.println("  üì° PUT " + path);
      Request req = new Request(HttpMethod.PUT, path);
      if (body != null) req.setBody(body);
      RESULT = req;
    :}
  | DELETE STRING:path SEMICOLON
    {: 
      //System.out.println("  üì° DELETE " + path);
      RESULT = new Request(HttpMethod.DELETE, path);
    :}
  | assertion:a
    {: 
      RESULT = a;
    :}

  //ERROR_RULE: missing semicolon after request
  | GET STRING:path error:e
    {:
      int line = ((Symbol)e).left + 1;
      parser.report_error("expected ';' after request at line " + line, e);
    :}

  // ERROR_RULE: missing semicolon after POST request
  | POST STRING:path LBRACE request_body RBRACE error:e
    {:
      parser.report_error("expected ';' after request", e);
    :}

  // ERROR_RULE: missing semicolon after PUT request
  | PUT STRING:path LBRACE request_body RBRACE error:e
    {:
      parser.report_error("expected ';' after request", e);
    :}

  // ERROR_RULE: missing semicolon after DELETE request
  | DELETE STRING:path error:e
    {:
      parser.report_error("expected ';' after request", e);
    :}
  ;

//statement_list can be one or more statements
statement_list ::=
    statement:s
    {: 
     //System.out.println("  ‚Üí 1 statement parsed");
      List<Statement> list = new ArrayList<>();
      list.add(s);
      RESULT = list;
    :}
  | statement_list:list statement:s
    {: 
      //System.out.println("  ‚Üí Another statement parsed");
      list.add(s);
      RESULT = list;
    :}
  ;

//assertion rule
assertion ::=
    EXPECT STATUS EQUALS NUMBER:code SEMICOLON
    {: 
      //System.out.println("  ‚úì Expect status = " + code);
      RESULT = Assertion.status(Integer.parseInt(code));
    :}

  //ERROR_RULE: status must be an integer
  | EXPECT STATUS EQUALS error:e SEMICOLON
    {: 
      int line = ((Symbol)e).left + 1;
      parser.report_error("expected NUMBER for status at line " + line, e); 
    :}

  | EXPECT BODY CONTAINS STRING:text SEMICOLON
    {: 
      //System.out.println("  ‚úì Expect body contains: " + text);
      RESULT = Assertion.bodyContains(text);
    :}
  | EXPECT HEADER STRING:name EQUALS STRING:value SEMICOLON
    {: 
      //System.out.println("  ‚úì Expect header " + name + " = " + value);
      RESULT = Assertion.headerEquals(name, value);
    :}
  | EXPECT HEADER STRING:name CONTAINS STRING:substr SEMICOLON
    {: 
      //System.out.println("  ‚úì Expect header " + name + " contains: " + substr);
      RESULT = Assertion.headerContains(name, substr);
    :}
  ;

//request body (optional)
request_body ::=
    /* empty */
    {: 
      //System.out.println("    (no req body)");
      RESULT = null;
    :}
  | BODY EQUALS STRING:content SEMICOLON
    {: 
      //System.out.println("    üìÑ body = " + content);
      RESULT = content;
    :}

  //ERROR_RULE: Body must be a string
  | BODY:kw EQUALS error:e SEMICOLON
    {:
      errorAt("expected STRING after 'body ='", kwleft, kwleft);
      done_parsing();
    :}
  ;

//variable declaration
variable_decl ::=
    LET IDENTIFIER:name EQUALS STRING:value SEMICOLON
    {: 
      RESULT = new Variable(name, value);
      //System.out.println("üìå Variable: " + RESULT);
    :}
  | LET IDENTIFIER:name EQUALS NUMBER:value SEMICOLON
    {: 
      RESULT = new Variable(name, value);
      //System.out.println("üìå Variable: " + RESULT);
    :}

  // ERROR_RULE: Identifier cannot start with a digit
  | LET:kw NUMBER:bad
    {:
      // Point error to the 'let' keyword line for consistency
      errorAt("expected IDENT after 'let'", kwleft, kwleft);
      done_parsing();
    :}

  // ERROR_RULE: Identifier cannot start with a digit or other invalid token
  | LET:kw error:e
    {:
      errorAt("expected IDENT after 'let'", kwleft, kwleft);
      done_parsing();
    :}
  ;

//variable list (optional)
variable_list ::=
    /* empty */
    {: 
      // No RESULT needed
    :}
  | variable_list variable_decl:var
    {: 
      parser.program.addVariable(var); // No RESULT needed
    :}
  ;
